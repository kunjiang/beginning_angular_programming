# 服务与依赖注入

在 ng 中除了提供双向数据绑定的功能外, 还有其他常见的功能, 例如: cookie 与 localStorage 的存取, http ajax 请求,
location 处理, filter 功能等. 

对弈与以往开发模型, 如果需要提供新的功能, 无非就是引入新的 js 文件. 
但是在 ng 中不完全相同. 在 ng 中使用模块的概念, 对不同功能进行了封装( 打包 ). 
而模块, 我们可以看成一类功能打包的整体. 

那么, 在 ng 中如何使用这些打包的功能呢? 我们从以下几个方面来理解:

1. 不同的功能已什么方式存在?
2. 如何加载其他功能?
3. 模块中可以包含什么?
4. 如何加载模块?


## 服务( Service )

在 ng 中, 大量应用了面向对象的思想. 要使用特定的功能, 实际上就是调用特定的函数( 或 方法 ).
在 ng 中将不同的方法, 按照功能进行了分类, 并封装到指定的对象中, 并按照功能给对象命名. 
例如: 要进行地址栏的变更, 可以使用 location 对象. 要发送 ajax 请求, 则使用 http 对象. 
若要对插值的数据进行特殊语法过滤或转换, 则使用 filter 对象. 
总而言之, 要使用不同的方法, 就找不同的对象. 

在 ng 中, 这样包含了特定功能方法, 并给核心模态提供方法支持的对象, 我们称其为服务( services ).

事实上, 在 ng 中, `$rootScope` 以及其他 `$scope` 都是服务. 因为它们都是对象, 同时含有方法, 含有属性.
我们在使用双向数据绑定的时候, 需要使用这样的对象: 它们提供数据与行为的双向绑定功能.


## 依赖注入

在 ng 中, 如果需要使用某个服务, 实际上就是在 `scope` 上需要使用某一个服务. 
它有一个特殊的语法:

```javascript
    module.run( [ '$rootScope', '其他服务的名字', ..., function ( $rootScope, 其他服务的引用, ... ) {
        // ...
    } ] );
```

或者

```javascript
    module.controller( '控制器名',  [ '$scope', '其他服务的名字', ... function ( $scope, 其他服务的引用, ... ) {
        // ...
    } ] );
```

上面的语法似曾相识, 但又不完全一样. 原因是, 我们以前一直写成:

```javascript
    module.run( function ( $rootScope ) {
        // ...
    });
```

以及

```javascript
    module.controller( '控制器名', function( $scope ) {
        // ...
    });
```

前面我们提到过, 对于上面的代码, 函数内的所有写法不能修改. 
实际上在 ng 内部, 就是利用上面函数的参数名字, 来获得 ng 内部定义的同名的服务对象的.
也就是说, 回调函数写成:

```javascript
    function ( $scope, $filter, $location ) {
        // ...
    }
```

在 ng 执行的时候, 会将该函数先转换成字符串, 再利用正则表达式将函数内的参数名以字符串的形式获取出来.

```javascript
var rnames = /function.+\((.+?)\)\s*\{/; 
var m = rnames.exec( callback );
var serviceNames = m[ 1 ].split( ',' ).map( name => name.trim() );
```

利用上述代码, 即可获得对应的服务的名字, 然后将 ng 内部对应名字的服务取出, 传入到函数中直接使用. 
若 ng 内部找不到对应的服务名, 则会报错.

所以在前面使用 `$rootScope` 以及 `$scope` 的时候, 函数的参数不能随意更改既是该原因.

而其根本的实现, 就是本节给出来的语法形式. 我们以前的使用方式只是一种简化的写法, 其目的是为了方便使用.
而不允许修改函数参数的名字, 是因为一旦修改名字, ng 就无法找到对应名字的服务了.
事实上, 实际应用中, js 代码会被压缩, 而函数参数的名字也会随之更改与变短. 
因此之前的写法必须替换成本节开始描述的语法形式.












