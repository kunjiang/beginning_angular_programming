<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:README</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="-">下载与文档</h1>
<h2 id="-angular">下载 angular</h2>
<p>下载 angular( 后面简称为 ng )可以使用很多种方法:</p>
<ul>
<li>使用 npm 下载<pre><code>$ npm install angular --registry=https://registry.npm.taobao.org
</code></pre><img src="./imgs/2018-01-29_105704.png" alt="使用 npm 安装 angular"></li>
<li>使用 <a href="http://www.bootcdn.cn/angular.js/1.6.8/">CDN</a><pre><code class="lang-html">&lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.6.8/angular.js&quot;&gt;&lt;/script&gt;
&lt;!-- 或 --&gt;
&lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.6.8/angular.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
<li>使用<a href="https://angularjs.org/">官网</a>下载, 也可以进入所有的 release 版本的站点下载: <a href="https://code.angularjs.org/">https://code.angularjs.org/</a></li>
</ul>
<p>注: 个人建议初学者在官网下载所有的包, 因为里面包含了所有的常用库, 以及文档内内容.</p>
<h2 id="-1-6-8-">部署文档( 这里使用 1.6.8 为例 )</h2>
<p>学习和使用 ng 的时候可以使用<a href="https://docs.angularjs.org/">在线文档</a>, 也可以在本地部署</p>
<ul>
<li>下载完整的代码压缩包(<a href="https://code.angularjs.org/1.6.8/angular-1.6.8.zip">angular-1.6.8.zip</a>)</li>
<li>解压, 然后在解压目录下可以看到一个 docs 文件夹. 里面放置的就是文档( 值得注意的是, 该文档需要依赖外部的代码 )</li>
<li>然后在解压的目录下部署 http 服务器即可. </li>
</ul>
<p><img src="./imgs/2018-01-29_111511.png" alt="解压后文档的位置"></p>
<p><img src="./imgs/2018-01-29_111708.png" alt="部署 http 服务器"></p>
<p><img src="imgs/2018-01-29_111750.png" alt="在浏览器中访问"></p>
<p><img src="imgs/2018-01-29_111857.png" alt="浏览文档"></p>
<h1 id="-ng-vue-">传统开发和 ng 以及 vue 的区别概述</h1>
<h2 id="-">传统开发</h2>
<p>传统的 web 开发经历了好几个阶段</p>
<ul>
<li>静态网站阶段</li>
<li>后台渲染动态网站阶段</li>
<li>ajax 阶段( 前后台半分离阶段 )</li>
<li>前后分离阶段</li>
</ul>
<h3 id="-">静态网站阶段</h3>
<p>早期的网络只是为了通信, 传递信息. 是专有网络. 所以也不存在信息身份验证等内容. 
仅仅使用静态网站展示需要显示的文字信息. 但是随着网络发展越来越快, 
静态网站已经不再满足现在的需求. 例如, 无法实现搜索, 登录等模型.</p>
<h3 id="-">后台渲染动态网站阶段</h3>
<p>为了实现动态网站, 需要将很多逻辑在服务器生成, 然后在根据需要生成相应的 HTML 页面( HTML 字符串 ).
然后由服务器返回给浏览器, 用户再查看页面. </p>
<p><img src="./imgs/2018-01-29_112930.png" alt="传统动态网站模型"></p>
<p>但是该模型使得每次索要数据都会进行一次请求与响应过程. 而浏览器只有使用 form, 表单提交来实现该功能.
那么就会造成一个较为不友好的方式: 页面重新加载. 试想一下, 在看到好电影时, 想要发表一个评论, 
提交后页面重新加载 ... 然后再等一分钟广告?</p>
<p><img src="./imgs/2018-01-29_113913.png" alt="提交数据后浏览器会重新加载"></p>
<h3 id="ajax-">ajax 阶段( 前后台半分离阶段 )</h3>
<p>为了提高用户体验(在接收数据的时候, 浏览器不进行重新加载页面), Ajax 技术不断的被使用.
异步的提交请求, 不影响页面的正常显示与运行. 然后请求被服务器处理, 响应回来后触发一个回调函数,
在回调函数中利用 DOM 操作对页面进行处理.</p>
<p><img src="./imgs/2018-01-29_114937.png" alt="ajax 下的网站模型"></p>
<p>随着移动端的慢慢兴起, 需要配合多个尺寸的客户端, 同时需要移动设备开启时有较好的用户体验, 
慢慢的需要将全台渲染完全从后台移到前台. </p>
<ul>
<li>传统后台提供数据与界面的代码, 因此分离后后台只需要提供数据, 将面渲染的行为交给前端(浏览器). 这样不仅降低了服务器压力, 也使得适配变得容易.</li>
<li>将界面的处理交给浏览器. 在移动设备上, 浏览器可以保存一部分数据. 在启动 app 的时候, 可以展示上次关闭时的界面, 同时异步请求最新数据.待请求数据返回后更新界面. 从而不会出现页面加载时的白屏, 提升用户体验.</li>
</ul>
<h3 id="-">前后分离阶段</h3>
<p>前后分离是 web 开发的趋势. 将所有的界面交互与应用交给浏览器执行, 所有的数据加载都使用 ajax 异步请求. 第一次请求一个界面的外壳, 或许带有少量数据. 然后在使用过程中不断按需请求数据, 加载数据. 从而诞生单页面应用程序. 将整个 web 看成一个独立的 app.</p>
<p>将前端独立出来后, 诞生出大量前端框架, 提供一整个生态系统. 对于前端开发者, 重心可以更加专注与用户与界面.</p>
<h2 id="-angular-vue-">传统开发与 angular 和 vue 的直观对比</h2>
<p>angular 与 vue 属于一类框架( 也可以简单的称之为库, 解决方案等 ), 都属于 MV* 系列框架.
利用面向对象的方式去封装界面中的各种功能( 组件或模块 ). </p>
<p>传统的页面操作( jQuery 时代 )是站在 DOM 模型的基础上, 将 html, 原本一个结构化字符串, 看成一棵对象树.
利用提供的 DOM 方法对树中的各个节点( node 节点 )进行增加节点, 删除节点, 修改节点属性或样式, 以及查询指定节点等操作.
从而实现界面的交互. </p>
<p>例如目录展开, 利用的是点击事件加修改元素的 <code>display</code> 样式.</p>
<pre><code class="lang-javascript">var a_list = document.querySelectorAll( &#39;.menu-title&#39; );
Array.prototype.slice.call( a_list ).forEach(elem =&gt; {
    elem.onclick = function () {
        var ul = this.nextSibling.nextSibling;
        var classNames = ul.className.split( &#39; &#39; );
        var i = -1;
        if ( ( i = classNames.indexOf( &#39;hide&#39; ) ) &gt; -1 ) {
            classNames.splice( i, 1 );
        } else {
            classNames.push( &#39;hide&#39; );
        }
        ul.className = classNames.join( &#39; &#39; );
    }
});
</code></pre>
<p>虽然传统的 DOM 操作也是在使用 面向对象. 但是其颗粒度非常的细. 它将每一个标签都看成对象, 所以对于较大的代码逻辑, 
实际操作起来依旧会很麻烦. 但是如果使用 MV* 的框架, 将整个逻辑单元看成对象( 一个对象中可能包含很多标签 ). 
例如还是以菜单为案例, 在 angular 或 vue 中, 可以将整个菜单看成对象. 而其中利用数据驱动界面这一特征, 
使得上述代码实现起来极为简单.</p>
<p>例如在 vue 中, html 部分( 片段 )为:</p>
<pre><code class="lang-html">&lt;ul&gt;
    &lt;li id=&quot;app1&quot;&gt;&lt;a class=&quot;menu-title&quot; v-on:click=&quot;myclick&quot;&gt;一级菜单1&lt;/a&gt;
        &lt;ul v-show=&quot;ishide&quot;&gt;
            &lt;li&gt;二级菜单1.1&lt;/li&gt;
            &lt;li&gt;二级菜单1.2&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li id=&quot;app2&quot;&gt;&lt;a class=&quot;menu-title&quot; v-on:click=&quot;show = !show&quot;&gt;一级菜单2&lt;/a&gt;
        &lt;ul v-show=&quot;show&quot;&gt;
            &lt;li&gt;二级菜单2.1&lt;/li&gt;
            &lt;li&gt;二级菜单2.2&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>其代码为:</p>
<pre><code class="lang-javascript">new Vue({
    el: &#39;#app1&#39;,
    data: {
        ishide: false
    },
    methods: {
        myclick: function () {
            this.ishide = !this.ishide;
        }
    }
});

new Vue({
    el: &#39;#app2&#39;,
    data: {
        show: false
    }
});
</code></pre>
<p>angular 的实现更有意思, 可以不写一句 js 代码:</p>
<pre><code class="lang-html">&lt;div ng-app ng-init=&quot;menu1 = menu2 = menu3 = false&quot;&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;a class=&quot;menu-title&quot; ng-click=&quot;menu1 = !menu1&quot;&gt;一级菜单1&lt;/a&gt;
            &lt;ul ng-show=&quot;menu1&quot;&gt;
                &lt;li&gt;二级菜单1.1&lt;/li&gt;
                &lt;li&gt;二级菜单1.2&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a class=&quot;menu-title&quot; ng-click=&quot;menu2 = !menu2&quot;&gt;一级菜单2&lt;/a&gt;
            &lt;ul ng-show=&quot;menu2&quot;&gt;
                &lt;li&gt;二级菜单2.1&lt;/li&gt;
                &lt;li&gt;二级菜单2.2&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a class=&quot;menu-title&quot; ng-click=&quot;menu3 = !menu3&quot;&gt;一级菜单3&lt;/a&gt;
            &lt;ul ng-show=&quot;menu3&quot;&gt;
                &lt;li&gt;二级菜单3.1&lt;/li&gt;
                &lt;li&gt;二级菜单3.2&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<p>注意: 这里的代码逻辑可能让部分初学者不知所云, 这里不用担心, 后面我们会详细的加以说明.</p>
<p>在 MV* 框架中, 将整个菜单看成一个对象.在 angular 中( 由于该讲义为 ng 基础讲义, 这里用 angular 做说明 ), 
这个对象的显示范围由 <code>ng-app</code> 来标记, 凡是 <code>ng-app</code> 包含的范围都属于该对象所维护的区域. </p>
<p>同时在 该对象中维护了三个属性, 分别是 <code>menu1</code>, <code>menu2</code>, 以及 <code>menu3</code>. 
在代码中使用 <code>ng-init</code> 将这三个变量初始化为 <code>false</code>. 实际上这个 <code>ng-init</code> 可以省略.</p>
<p>同时在这个对象中, 使用 <code>ng-click</code> 注册了三个点击事件, 在点击事件中, 对对应的变量取反. 即 <code>true</code> 变成 <code>false</code>,
而 <code>false</code> 变成 <code>true</code>. </p>
<p>另外在子菜单上使用 <code>ng-show</code> 来根据对应的 变量 来控制当前标签是否显示.</p>
<p>如此, 只要点击对应的 <code>a</code> 标签, 就会触发相应的 <code>click</code> 事件, 即会将对应的 <code>menu</code> 变量取反.
同时由于对应的变量发生变化, 会随之将子菜单( 含有 <code>ng-show</code> 的标签 )的显示情况进行修改. 
如果变量为 <code>true</code> 则显示; 若变量为 <code>false</code> 则隐藏.</p>
<h2 id="mvvm-">MVVM 开发模型简述</h2>
<p>angular 是一个 MVVM 的框架, 这里第一个 M 是 Model, 即模型, 是表示数据模型的含义. 
这里的第二个字符 V 是 View, 表示视图, 即用于显示的界面. 它一般是一个模板, 套用数据后就可以得到想要的显示.
接下来的 VM 是 ViewModel, 即视图模型. 用于联系视图与数据模型的桥梁. 一般用于控制显示. </p>
<p>在 MV* 系列的概念中, 存在诸多争议, 实际上这些争议都是仁者见仁智者见智. 初学者不需要深究 MVC 还是 MVVM.
建立好操作模型比较重要. </p>
<p>在 传统的 DOM 操作中, 重点在造作页面的步骤. </p>
<ul>
<li>找出需求, 抽象出数据模型.</li>
<li>然后确定需要处理什么元素, 接着找到该元素.</li>
<li>然后确定算法, 按照算法一步步操作元素.</li>
<li>最后再来决定是否需要优化.</li>
</ul>
<p>也就是说, 传统的做法, 即使是使用 DOM 对象, 但是将重点依旧放在了处理步骤上, 还是采用的过程化思维.</p>
<p>而 MVVM 则不同, 它完全采用面向对象的思想. ng 中将需要处理的页面( <code>ng-app</code> 标记的标签 )看成一个模块( module, 
初学者直接将其与对象可以等同 ), 然后在模块中抽象出数据模型. 并在界面中使用各种指令( directive )来关联背后的对象.
angular 框架帮我们完成了关联与联动的任务, 我们不用关系其具体的实现. 
在使用 angular 框架后, 原本要操作界面 dom 的步骤转而变成操作背后的对象, 我们修改对象的属性或成员. angular 帮我们将这个修改作用到页面的 DOM 上, 从而实现: <em>操作背后的对象, 即操作界面的元素</em>. </p>
<p>例如代码逻辑:</p>
<p>html 部分:</p>
<pre><code class="lang-html">&lt;div ng-app=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; ng-model=&quot;txt&quot; /&gt;
&lt;/div&gt;
</code></pre>
<p>js 部分:</p>
<pre><code class="lang-javascript">angular.module( &#39;app&#39;, [] )
    .run(function ( $rootScope ) {
        $rootScope.txt = &#39;angular&#39;;
    });
</code></pre>
<p>使用 angular 后, 操作模型就变成下面的逻辑关系:</p>
<p><img src="./imgs/2018-01-29_160123.png" alt=""></p>
<p>我们操作背后对象的 <code>text</code> 属性</p>
<p><img src="./imgs/2018-01-29_160254.png" alt=""></p>
<p>会通知处于实时监视背后对象的 angular</p>
<p><img src="./imgs/2018-01-29_160341.png" alt=""></p>
<p>然后 angular 会将数据的改变同步到界面中的对应位置</p>
<p><img src="./imgs/2018-01-29_160445.png" alt=""></p>
<p>从而实现了操作对象, 然后对象帮我们操作页面这一逻辑. </p>
<p>同时 angular 还提供了将界面的操作同步到背后的对象上的逻辑. 依旧采用该这个模型. </p>
<p><img src="./imgs/2018-01-29_161809.png" alt=""></p>
<p>在我们修改界面的数据后会触发 angular 的监听行为</p>
<p><img src="./imgs/2018-01-29_161908.png" alt=""></p>
<p>从而将数据同步到背后的对象中. 以该代码为例, 背后的对象就是 <code>$rootScope</code></p>
<p><img src="./imgs/2018-01-29_162109.png" alt=""></p>
<p>这样就可以实现: 取页面中元素的数据, 可以直接从背后的对象上取得, 不需要处理 dom.</p>
<p>最终如果要验证, 我们可以将 <code>$rootScope</code> 映射到全局对象上来查看:</p>
<p><img src="./imgs/two_way_data_binding.gif" alt=""></p>
<p>注意: 由于将 <code>$rootScope</code> 放到了 ng 结构的外部, 所以在数据修改后需要手动调用一个 <code>$apply()</code> 方法. 如果是在 ng 代码结构的内部就不需要. 这里的细节可以先暂时不考虑, 重点是思想, 代码编写思维的变化.</p>
<h2 id="-">小结</h2>
<p>本节我们讨论了传统开发与使用 angular 开发的区别. </p>
<ul>
<li>传统开发注重细节</li>
<li>angular 是 MVVM 的框架, 将直接操作 DOM 转变成操作 对象, 而 ng 将这个操作同步到界面中</li>
<li>同时 ng 还提供将界面数据的修改同步到背后的对象上, 使得我们需要获得页面的数据, 可以直接从对象上取得.</li>
</ul>
<p>同时抽象出来 MVVM 的模型图, 该图现在也许会对部分同学造成困惑, 可以先记住它, 在后续的代码中慢慢体会其意义:</p>
<p><img src="./imgs/2018-01-29_164733.png" alt=""></p>
<h1 id="ng-">ng 基本模型</h1>
<p>作为初学者使用 ng 的步骤可以归纳为:</p>
<ul>
<li>引入 ng 包<pre><code class="lang-html">&lt;script src=&quot;xxxx/angular.js&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
<li>在页面中需要用 ng 处理的标签上写上 <code>ng-app=&quot;模块名&quot;</code>. 此处的模块名与标识符的命名约定一样. 一般用于学习可以将 <code>ng-app</code> 写在 <code>body</code> 标签上.</li>
<li>在需要使用 ng 处理的代码上使用 <code>ng-model</code> 来关联前后的变量名, 该名字即会成为背后对象的属性, 即可实现前后数据的同步.</li>
<li>然后创建 <code>script</code> 标签, 并使用代码 <code>angular.module( &#39;模块名&#39;, [] )</code>, 来创建模块. 其中模块名即为 <code>ng-app</code> 后面的名字, 而方法中紧跟的 <code>[]</code> 表示依赖模块. 后面会详细讨论到模块的依赖, 这里先空着. </li>
<li><code>angular.module</code> 方法返回一个模块对象, 我们可以使用变量接收, 然后使用变量进行后续操作. 也可以使用链是编程, 来提供后面的代码处理.<pre><code class="lang-javascript">// 例如:
var app = angular.module( &#39;app&#39;, [] );
app.run( function ( $rootScope ) {
  $rootScope.text = &#39;初始化文本&#39;;
});
// 亦或使用链是编程格式
angular.module( &#39;app&#39;, [] )
     .run(function ( $rootScope ) {
          $rootScope.text = &#39;初始化文本&#39;;
      });
</code></pre>
</li>
</ul>
<p>注意: </p>
<ul>
<li>上述方法也就是只是在演示 ng 的一般使用方法. 这个步骤是最简单的, 但是要灵活使用 ng 的各种功能, 我们还需要学习很多后续内容.</li>
<li>对于很多案例, ng 几乎可以不写任何代码. 但是这仅仅是在演示 ng 的强大, 没有实际意义. 实际开发是不会使用哪种什么 js 也不写的结构, 这个演示只是一个噱头而已.</li>
<li>页面上默认只允许有一个 <code>ng-app</code> 的属性, 所以不要创建多个. 按照 ng 的思想, 将一个页面看成一个 app, 一个大的对象.</li>
<li>在标签中写的, 诸如 <code>ng-xxx</code> 的属性被称为指令( directive ), 是 ng 强大的核心. ng 中大多数功能都是利用给标签添加指令来实现的. 所谓指令, 其实就是在说明某个标签需要执行某些额外的处理.</li>
</ul>
<h2 id="-">简单案例</h2>
<p>在页面中显示一个文本框, 和一个按钮. 文本框默认显示 0, 点击按钮后文本框中的数字自动加一.</p>
<p>该案例的传统处理方法请读者自行实现, 以体会 ng 带来的好处, 具体代码可以参考 demo 文件夹.</p>
<p>下面用 ng 来实现, 首先我们考虑一下这个业务如何抽象出对象模型.</p>
<p>首先需要实现累加计算, 那么页面中的文本框, 就是需要与背后对象数据同步的结构. 因此在文本框中可以使用 <code>ng-model</code> 来提供数据的名字. 即背后的对象也会使用该名字. 例如:</p>
<pre><code class="lang-html">&lt;body&gt;
    &lt;input type=&quot;text&quot; ng-model=&quot;txt&quot; /&gt;&lt;button&gt;click&lt;/button&gt;
&lt;/body&gt;
</code></pre>
<p>然后在点击按钮的时候会使得该数据变化, 也就是说要在按钮上绑定事件. 这里使用 ng 的事件指令 <code>ng-click</code>. </p>
<p>它的用法与 <code>onclick</code> 类似. 在传统 <code>onclick</code> 的用法中有这样一种用法:</p>
<pre><code class="lang-html">&lt;button onclick=&quot;alert( &#39;点击了按钮&#39; )&quot;&gt;click&lt;/button&gt;
</code></pre>
<p>在点击该按钮后, 会执行 click 事件, 即将 <code>onclick</code> 中的字符串作为代码来执行. 在逻辑上就好像写在 <code>onclick</code> 
中的字符串, 就是一个匿名函数一样. 在点击按钮的时候就会触发该事件, 即会调用该事件处理函数. </p>
<p>同样在 ng 中, <code>ng-click</code> 的用法也是如此. 但是略有不同. 如果写成: </p>
<pre><code class="lang-html">&lt;button ng-click=&quot;myclick()&quot;&gt;click&lt;/button&gt;
</code></pre>
<p>代码在运行的时候, 字符串 <code>&quot;myclick()&quot;</code> 也会当做 &quot;匿名函数&quot; 来执行. 不同的是该匿名函数的上下文是我们前文中提到的 
&quot;背后的对象&quot;. </p>
<p>我们知道在 MVVM 中将 dom 操作转换成了对对象的操作, 也就是说在页面的背后会有一个对象. 我们在页面中使用的所有 
<code>ng-model</code> 提供的名字都是这个对象的属性. 同样我们使用 <code>ng-click</code> 里面的方法都是这个对象的方法. </p>
<p>即这里使用 <code>&lt;button ng-click=&quot;myclick()&quot;&gt;click&lt;/button&gt;</code> 表示背后的对象上有一个方法, 方法名为 <code>myclick</code>,
在点击该按钮后, 就会调用该对象的这个方法. </p>
<p>综上我们可以得到一个对象结构:</p>
<pre><code class="lang-javascript">var $rootScope = {
    txt: 0,
    myclick: function () {
        // ...
    }
};
</code></pre>
<p>这个对象结构与前面的界面互相关联. 按照前面 MVVM 的逻辑, 凡是在页面中修改了文本框的内容, 
ng 就会把数据同步到该对象的 <code>txt</code> 属性上. 在界面上点击按钮, ng 就会触发调用 <code>myclick</code> 方法. </p>
<p>反过来, 我们如果在 ng 代码中修改了 <code>txt</code> 属性, 即会将该属性值同步到 界面上. 
这里需要注意的是在 ng 的代码内部修改, 那么代码内部在哪呢? 看下面代码:</p>
<pre><code class="lang-javascript">angular.module( &#39;app&#39;, [] )
       .run( function ( $rootScope ) {
           // 哪里是 ng 内部???
       });
</code></pre>
<p>很显然, 所谓的 ng 代码内部就是在 run 方法参数中的这个回调函数里. 因此我们只需要在点击触发的 <code>myclick</code> 
方法里处理 <code>txt</code> 属性即可. </p>
<p>综上所述, 代码可以写成:</p>
<pre><code class="lang-html">&lt;body ng-app=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; ng-model=&quot;txt&quot;&gt;&lt;button ng-click=&quot;myclick()&quot;&gt;click&lt;/button&gt;
    &lt;script&gt;
        angular.module( &#39;app&#39;, [] )
               .run( function ( $rootScope ) {
                    $rootScope.txt = 0;
                    $rootScope.myclick = function () {
                        this.txt = this.txt - 0 + 1;
                    };
               });
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>注意: </p>
<ul>
<li>在页面运行的时候, <code>run</code> 方法仅会调用一次, 所以可以将初始化的代码写在这里.</li>
<li>在该代码结构中可以看到方法 <code>myclick</code> 直接绑定到了 <code>$rootScope</code> 上, 也就是说其上下文( 就是 <code>this</code> )是 <code>$rootScope</code>. </li>
<li>由于文本框中存储的是字符串, 所以要先减去 <code>0</code>, 以转换成数字后再加 <code>1</code>.</li>
</ul>
<h3 id="-">根据上述分析, 大家可以做一个练习</h3>
<p>要求在页面中放置两个文本框, 对其中一个文本框输入数据, 另一个文本框同步该输入( 请先思考在实现, 不要看答案 ). 
演示效果如下:</p>
<p><img src="./imgs/exercise0001.gif" alt=""></p>
<h2 id="-">一些简单结论</h2>
<ul>
<li>在 ng 中, 凡是在页面中使用了 <code>ng-app</code> 即在代码背后存在一个对象. 该对象就是 <code>$rootScope</code>.</li>
<li>在 ng 中, 凡是需要对页面中的数据进行操作, 都应该使用 <code>ng-model</code>, 将该操作转接到背后的对象上.</li>
<li>在 ng 中, 凡是使用了指令, 在指令中使用的内容似乎都应该是背后的对象 <code>$rootScope</code> 的属性或方法.</li>
</ul>
<h1 id="-">数据绑定与表达式</h1>
<p>从前文的介绍中可以看到, 界面的 html 中可以使用 <code>ng-xxx</code> 的属性命名一些名字. 
然后背后的对象上维护对应的属性, 即可实现前后的同步.</p>
<p>这样将界面中的 &quot;名字&quot; 与背后的对象的绑定被称之为数据的绑定. </p>
<p>在界面中使用 <code>ng-model</code>, 可以实现双向数据绑定. 即<em>界面修改同步背后属性修改, 背后属性修改同步界面修改</em>.</p>
<h2 id="-ng-bind-data-bind-"><code>ng-bind</code> 单向数据绑定( data-bind )</h2>
<p>在标签中还可以使用 <code>ng-bind</code> 来实现单向的绑定. 在界面中呈现数据, 往往是以展示数据为主( 这个看项目需求, 并非绝对 ).
例如展示数据列表, 某个页面的菜单, 某个网站的站点导航等. 这些数据不需要用户修改. 一般只有在表单处理, 
或需要记录数据的时候才需要用户输入. </p>
<p>所以并非每一个标签中都要使用 <code>ng-model</code>, 如果只需要单向绑定. 即背后对象属性修改, 就触发前面界面的数据修改. 
那么可以使用 <code>ng-bind</code> 指令. </p>
<p>它的使用与 <code>ng-model</code> 一模一样, 唯一不同的是, 不需要写到输入框中. 例如案例: </p>
<pre><code class="lang-html">&lt;body ng-app=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;br&gt;
    你好, &lt;span ng-bind=&quot;name&quot;&gt;&lt;/span&gt;
    &lt;script&gt;
        angular.module( &#39;app&#39;, [] )
                .run( function ( $rootScope ) {
                    $rootScope.name = &#39;jim&#39;;
                });
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>分析:</p>
<ul>
<li>在 <code>run</code> 方法中初始化对象 <code>$rootScope</code> 的 <code>name</code> 属性为 <code>&#39;jim&#39;</code>. </li>
</ul>
<p><img src="./imgs/2018-01-30_151026.png" alt=""></p>
<ul>
<li>对属性的设置触发 ng 将数据同步到界面中.</li>
<li>页面中使用 <code>ng-bind</code> 的标签内部会使用对应的数据进行填充( 注意, 默认不允许 html 字符串 ). 使用 <code>ng-model</code> 的输入框亦会如此.</li>
</ul>
<p><img src="./imgs/2018-01-30_151139.png" alt=""></p>
<ul>
<li>在前台界面的文本框中输入数据的时候, 会触发 ng 将界面的数据变化记录下来, 并通知背后的对象.</li>
<li>将数据同步到背后的 <code>$rootScope</code> 对象的 <code>name</code> 属性上.</li>
</ul>
<p><img src="./imgs/2018-01-30_151225.png" alt=""></p>
<ul>
<li>由于此同步使得 <code>$rootScope.name</code> 发生变化, 又会触发一次 ng 监视同步行为. </li>
<li>将该数据同步到界面的 <code>ng-bind</code> 所在的标签中.</li>
<li>从后向前的同步会同时发生在 <code>ng-bind</code> 和 <code>ng-model</code> 上, 但是由于此次同步的数据, 与 <code>ng-model</code> 中的数据相同, 所以不会进行数据的修改, 也就不会再发生同步逻辑. 事实上, 如果依旧有数据变化, 还是会触发一次同步逻辑. 在 ng 中这个循环会在执行到 第 10 次的时候强制终结, 并抛出一个异常. </li>
<li>由于 <code>ng-bind</code> 是单向数据绑定, 因此在界面中它的数据变化不会触发 angular 监视行为.</li>
</ul>
<p><img src="./imgs/2018-01-30_151327.png" alt=""></p>
<p>在 ng 中数据绑定的案例特别多. 除了使用 <code>ng-bind</code> 外, 在页面中还可以使用插值语法.</p>
<h2 id="-interpolation-">插值( interpolation )</h2>
<p>在 ng 中提供一种插值语法. 默认使用双花括号括起来. 例如: </p>
<pre><code class="lang-html">&lt;p&gt;你好, {{ name }}&lt;/p&gt;
</code></pre>
<p>使用 <code>ng-bind</code> 固然很好, 但是在一些 DOM 属性中, 或是一些字符串中就无法使用了. 因为它必须写在标签上. 但是插值语法就要容易得多. 
例如刚才那个案例:</p>
<pre><code class="lang-html">&lt;body ng-app ng-init=&quot;name=&#39;jim&#39;&quot;&gt;
    &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;/&gt;
    &lt;br /&gt;
    你好, {{ name }}
&lt;/body&gt;
</code></pre>
<p>该代码的执行分析与上一个案例一致. 这里仅仅是在比较插值语法与 <code>ng-bind</code> 的方便之处.</p>
<h2 id="-expression-">表达式( expression )</h2>
<p>在编程语言中, 表达式是由数据与运算符连接起来具有计算结果的语法结构, 或运算结构. 但是在 ng 中这一概念被推广.</p>
<p>在 <a href="https://code.angularjs.org/1.5.11/docs/guide/expression">ng 官网文档</a>中这么定义:</p>
<!-- 
Angular expressions are JavaScript-like code snippets that are mainly placed in interpolation bindings such as <span title="{{ attrBinding }}">{{ textBinding }}</span>, but also used directly in directive attributes such as ng-click="functionExpression()".
 -->
<pre><code>Angular 表达式是一个类似于 JavaScript 的代码片段. 该代码片段主要用于数据绑定中插值的替换. 
例如: &lt;span title=&quot;{{ attrBinding }}&quot;&gt;{{ textBinding }}&lt;/span&gt;, 同时也用于指令属性中.
例如: ng-click=&quot;functionExpression()&quot;
</code></pre><p>换句话说, 我们之前使用的 <code>ng-bind</code>, <code>ng-click</code>, <code>ng-model</code> 等指令中的内容都是 angular 的表达式.</p>
<p>那么在 ng 中的表达式与 以前讨论的 javascript 的表达式有什么区别呢?</p>
<h3 id="-">首先上下文不同</h3>
<p>在 javascript 中, 一般表达式的上下文为全局的 <code>window</code>( 闭包中的除外 ). 例如调用一个函数, 
实际上是调用全局对象 <code>window</code> 的方法. </p>
<p>而 ng 中, 上下文为当前标签背后的对象, 即前面讨论的 <code>$rootScope</code>. 所以常常出现的错误中有一个就是弄错了上下文. </p>
<p>例如要实现两个文本框的自动求和的逻辑. 下面的代码就无法运行成功:</p>
<pre><code class="lang-html">&lt;body ng-app&gt;
    &lt;input type=&quot;text&quot; ng-model=&quot;num1&quot;&gt;
    +
    &lt;input type=&quot;text&quot; ng-model=&quot;num2&quot;&gt;
    =
    &lt;span ng-bind=&quot; parseInt( num1 ) + parseInt( num2 ) &quot;&gt;&lt;/span&gt;
&lt;/body&gt;
</code></pre>
<p>这里运行没有结果, 原因是表达式中使用了 <code>parseInt</code>, 也就是说 ng 会假定该方法是 <code>$rootScope</code> 的.
但是很显然没有该方法, 古不会有任何结果. 这一点也是 ng 表达式的特点, 在表达式中, 处理了不存在的数据,
或调用了不存在的方法, 是不会报错的. </p>
<p>如果将最后一句代码修改为下面的样子, 就可以得到结果了:</p>
<pre><code class="lang-html">&lt;span ng-bind=&quot; ( num1 - 0 ) + ( num2 - 0 ) &quot;&gt;&lt;/span&gt;
</code></pre>
<h3 id="-">容错性</h3>
<p>好比上一个特点中提到的, 在 ng 中, 如果一个数据为 <code>null</code>( 或 <code>undefined</code> ), 而求其属性的值, 
则会得到一个异常. </p>
<p>但是在 ng 中, 无论是对象为 <code>null</code> 还是 <code>undefined</code>, 该计算都不会出现错误.</p>
<h3 id="ng-">ng 可以使用过滤器</h3>
<p>在 ng 中含有一种特殊的语法, 允许在表达式中使用 过滤器( filter ). 所谓的过滤器, 是一种处理数据,
或格式化数据的函数. 它可以将数据处理成我们想要的形式. 例如下面代码: </p>
<pre><code class="lang-html">&lt;body ng-app ng-init=&quot;money=123&quot;&gt;
    &lt;p&gt;{{ money }}&lt;/p&gt;
    &lt;p&gt;{{ money | currency }}&lt;/p&gt;
    &lt;p&gt;{{ money | currency: &#39;¥&#39; }}&lt;/p&gt;
&lt;/body&gt;
</code></pre>
<p>其运行结果为:</p>
<p><img src="./imgs/2018-01-30_160735.png" alt=""></p>
<p>竖线是过滤器语法, 过滤器 <code>currency</code> 实际上是一个函数. 该函数提供两个参数, 
一个参数是竖线前面的值( 一般就是前面绑定的属性 ), 另一个参数是过滤器后面冒号后的参数.
该过滤器的目的是将数据以货币的形式进行输出, 即数字后需要带有两个小数位. 
同时在数字前面带有货币的类别字符. 如果 <code>currency</code> 后面没有参数, 即默认参数为美元符.</p>
<p>ng 支持很多过滤器, 还支持自定义过滤器. 至于过滤器的细节我们后面再讨论.</p>
<h3 id="-">不允许流程控制</h3>
<h3 id="-">不允许函数定义</h3>
<h3 id="-">不允许包含正则字面量</h3>
<h3 id="-new-">不允许使用 new 关键字</h3>
<h3 id="-void-">不允许使用位运算, 逗号运算和 void 运算符</h3>
<p>在 ng 表达式中有很多不允许, 大多数不允许是因为 ng 背后会利用词法分析的方式解析表达式.
而流程控制, 斜线, new 等内容都会影响到解析的算法. 至于不允许使用位运算符, 
是因为 竖线已经是过滤器的语法结构了.</p>
<p>一般正常使用表达式不会有什么问题. 核心需要注意的是 ng 中表达式中的每一个标识符, 都会对应背后对象的属性.</p>
<h1 id="-">常用内置指令</h1>
<p>所谓的指令( directive ), 就是额外需要执行代码的标记. 
ng 中我们已经接触过的指令有: <code>ng-app</code>, <code>ng-init</code>, <code>ng-model</code>, <code>ng-bind</code>, <code>ng-show</code>, <code>ng-click</code> 等.</p>
<p>指令就是额外需要执行的标记, 例如 <code>ng-app</code> 一写, 就会使 ng 将该标签以及其所有子标签作为维护的标签, 
同时背后就会创建一个维护的对象. </p>
<p>再如, <code>ng-init</code> 表示初始化, 凡是在该指令中写的赋值逻辑, 都会在背后的对象中初始化对应的属性.</p>
<p>又如 <code>ng-model</code>, 凡是出现在其中的标识符, 都会在背后提供对应属性. 同时 ng 会自动帮助我们添加事件与监听的方法. 
只要一侧数据发生变化就会触发同步.</p>
<p>...</p>
<p>综上所述, 凡是写到指令的地方, 就是在该范围内需要额外的执行逻辑. </p>
<p>在 ng 中还有很多的指令. ng 中指令有四种形式:</p>
<ul>
<li>以属性的形式存在. 前面接触的指令均是如此.</li>
<li>以标签的形式存在. 例如 <code>ng-view</code> 等, 后面会陆续说明.</li>
<li>以 class 的形式存在. 这个相对使用较少.</li>
<li>以注释的形式存在. 这个我们自己使用的较少.</li>
</ul>
<p>接下来我们一一举例说明常用的指令( <strong>该部分只会介绍该阶段可以使用的指令, 部分指令还需要后续内容支撑</strong> ).</p>
<p>可以参考<a href="https://docs.angularjs.org">文档</a>中的 directive 部分 </p>
<h2 id="-">控制指令</h2>
<p>这里我们介绍 <code>ngIf</code> 和 <code>ngRepeat</code> 指令的用法.</p>
<blockquote>
<p>注意: 在 ng 中, 所有的指令描述都采用 骆驼命名规则. 但是在 html 中使用的时候, 均采用 连字符 连接的小写字符形式.</p>
</blockquote>
<h3 id="ngif-">ngIf 指令</h3>
<p>该指令语法:</p>
<pre><code class="lang-html">&lt;tag ng-if=&quot;表达式&quot;&gt;...&lt;/tag&gt;
</code></pre>
<p>其含义为, 如果 <code>ng-if</code> 中绑定的数据, 表达式的值如果为 <code>true</code>, 则表示该标签会呈现在 DOM 结构中.
若该表达式的值为 <code>false</code>, 则该标签就不会出现在 DOM 树中. 注意不是隐藏, 是根本就不会出现在 DOM 结构中.</p>
<p>看下面代码:</p>
<pre><code class="lang-html">&lt;body ng-app&gt;
    &lt;div ng-if=&quot;exist&quot;&gt;
        测试数据
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>运行查看代码的 DOM 结构:</p>
<p><img src="./imgs/2018-02-01_153849.png" alt=""></p>
<p>简单分析:</p>
<ul>
<li>页面加载运行, 由于 <code>ng-app</code> 后面没有提供任何名字. 因此 我们不用编写任何代码, ng 会自动维护一个背后的对象.</li>
<li>由于标签中没有提供 <code>ng-init</code> 指令, 所以在背后对象中, 没任何成员.</li>
<li>而标签中的 <code>ng-if</code> 指令中使用了 表达式 <code>exist</code>, 而背后的对象中又没有该属性, 即表达式的值为 <code>undefined</code></li>
<li>因此 <code>ng-if</code> 表达式的值为 <code>false</code>, DOM 结构中不会提供该节点.</li>
</ul>
<p>如果在代码中加上下面代码结果会怎样呢? 请自行分析运行的原理.</p>
<pre><code class="lang-html">...
&lt;body ng-app ng-init=&quot;exist=1&quot;&gt;
...
</code></pre>
<h3 id="ngrepeat-">ngRepeat 指令</h3>
<p><code>ng-repeat</code> 指令允许在页面中利用数据构造结构重复的标签. 例如菜单结构, 表格结构, 选项卡结构等.
其语法为:</p>
<pre><code class="lang-html">&lt;tag ng-repeat=&quot;迭代变量 in 集合&quot;&gt;...&lt;/tag&gt;
</code></pre>
<p>需要哪一个标签重复生成, 这个指令就放到哪一个标签上. 例如需要生成一个 <code>ul-li</code> 的列表, 需要利用数组重复生成 <code>li</code> 标签,
那么就需要将 该指令 放在 <code>li</code> 标签上( 注意不是放在 <code>ul</code> 标签上 ).</p>
<p>在 <code>ng-repeat</code> 的表达式中, &#39;集合&#39; 就是背后对象的成员. 而迭代变量有用户自己定义(需要满足标识符规则), 
类似于 js 中 for-in 循环语法. 该变量会在循环生成 <code>li</code> 标签的时候使用.</p>
<p>例如我们需要利用一个数组生成一个 <code>ul-li</code> 标签.</p>
<pre><code class="lang-html">&lt;body ng-app=&quot;app&quot;&gt;
    &lt;ul&gt;
        &lt;li ng-repeat=&quot;item in list&quot;&gt;{{ item }}&lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        angular.module( &#39;app&#39;, [] )
            .run(function ( $rootScope ) {
                $rootScope.list = [ 1, 2, 3 ];
            });
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>其运行结果为:</p>
<p><img src="./imgs/2018-02-01_155538.png" alt=""></p>
<p>简单分析:</p>
<ul>
<li>首先我们手动创建了一个模块, 并在背后的 <code>$rootScope</code> 对象上提供了 一个 属性 <code>list</code>, 里面存储数据 1, 2, 3.</li>
<li>然后页面中使用 <code>ng-repeat</code> 指令. 该指令遍历 <code>list</code>. </li>
<li>根据前文的说明, 凡是需要使用的名字都是背后对象的属性, 因此就是在遍历 数组 <code>[ 1, 2, 3 ]</code>.</li>
<li>每一次遍历都会创建一个临时变量 <code>item</code>, 我们称其为迭代变量. 由于数组中有三个数据, 因此会进行三次遍历, 每次 <code>item</code> 变量中存储的数据分别为 <code>1</code>, <code>2</code>, 和 <code>3</code>.</li>
<li>进行三次遍历就会创建 3 个 <code>&lt;li&gt;</code> 标签. 标签中利用插值将 item 的数据存储到 <code>li</code> 内.</li>
</ul>
<p>我们再来看一个较为复杂的案例:</p>
<p>我们有一个数据结构:</p>
<pre><code class="lang-javascript">var data = [
    { title: &#39;学习&#39;, submenus: [
        { title: &#39;传智播客&#39;, link: &#39;http://www.itcast.cn/&#39; },
        { title: &#39;黑马程序员&#39;, link: &#39;http://www.itheima.com/&#39; },
        { title: &#39;博学谷&#39;, link: &#39;https://www.boxuegu.com/&#39; },
        { title: &#39;传智专修学院&#39;, link: &#39;http://www.czxy.com/&#39; }
    ] },
    { title: &#39;前端项目&#39;, submenus: [
        { title: &#39;mdn-js&#39;, link: &#39;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript&#39; },
        { title: &#39;jquery&#39;, link: &#39;http://jquery.com/&#39; },
        { title: &#39;node&#39;, link: &#39;https://nodejs.org/en/&#39; },
        { title: &#39;vue&#39;, link: &#39;https://cn.vuejs.org/&#39; },
        { title: &#39;angular&#39;, link: &#39;http://angular.org/&#39; },
        { title: &#39;react&#39;, link: &#39;https://reactjs.org/&#39; },
        { title: &#39;git&#39;, link: &#39;https://github.com/&#39; }
    ] },
    { title: &#39;BAT&#39;, submenus: [
        { title: &#39;百度&#39;, link: &#39;https://www.baidu.com/&#39; },
        { title: &#39;阿里&#39;, link: &#39;https://www.aliyun.com&#39; },
        { title: &#39;腾讯&#39;, link: &#39;http://www.qq.com/&#39; } 
    ] }
];
</code></pre>
<p>要求利用 ng 来生成一个菜单. 效果如图:</p>
<p><img src="./imgs/2018-02-01_160944.png" alt=""></p>
<p>其 HTML 结构为: </p>
<p><img src="./imgs/2018-02-01_161038.png" alt=""></p>
<p>其代码的实现为:</p>
<pre><code class="lang-html">&lt;body ng-app=&quot;app&quot;&gt;
    &lt;div class=&quot;menu&quot;&gt;
        &lt;ul&gt;
            &lt;li ng-repeat=&quot;item in list&quot;&gt;
                &lt;a href=&quot;#&quot;&gt;{{ item.title }}&lt;/a&gt;
                &lt;ul class=&quot;submenu&quot;&gt;
                    &lt;li ng-repeat=&quot;subitem in item.submenus&quot;&gt;
                        &lt;a href=&quot;{{ submenu.link }}&quot; target=&quot;_blank&quot;&gt;{{ subitem.title }}&lt;/a&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script&gt;
        angular.module( &#39;app&#39;, [] )
            .run(function ( $rootScope ) {
                $rootScope.list = data;
            });
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>其运行的原理与过程请自行分析.</p>
<h3 id="-">内置的迭代成员</h3>
<p>使用 <code>ng-repeat</code> 的时候, 使用迭代变量来提供标签的数据. 这里的迭代变量就是集合中的数据.
例如数值数组, 迭代变量就是里面的数据; 对象数组, 迭代变量就是数组中的对象. 
如果需要使用其他的迭代数据, 例如遍历的序号等. ng 提供了一套内置的迭代成员.</p>
<table>
<thead>
<tr>
<th style="text-align:left">内置变量</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$index</td>
<td style="text-align:left">数字(从 0 开始)</td>
<td style="text-align:left">用于在迭代的过程中记录遍历时的序号(索引). 好比 <code>for</code> 循环中的 <code>i</code></td>
</tr>
<tr>
<td style="text-align:left">$first</td>
<td style="text-align:left">布尔类型</td>
<td style="text-align:left">用于判断当前项是否为第 0 项</td>
</tr>
<tr>
<td style="text-align:left">$middle</td>
<td style="text-align:left">布尔类型</td>
<td style="text-align:left">用于判断当前项是否为中间的项( 0 项与最后一项之间 ).</td>
</tr>
<tr>
<td style="text-align:left">$last</td>
<td style="text-align:left">布尔类型</td>
<td style="text-align:left">用于判断当前项是否为最后一项</td>
</tr>
<tr>
<td style="text-align:left">$even</td>
<td style="text-align:left">布尔类型</td>
<td style="text-align:left">用于判断当前项是否为偶数项</td>
</tr>
<tr>
<td style="text-align:left">$odd</td>
<td style="text-align:left">布尔类型</td>
<td style="text-align:left">用于判断当前项是否为奇数项</td>
</tr>
</tbody>
</table>
<h2 id="-">事件相关指令</h2>
<p>前文已经介绍过的事件相关的指令有 <code>ng-click</code>, 我们简要复习一下其用法.</p>
<ul>
<li>首先该指令的用法与时间类似, 写在 该指令中的字符串会作为代码进行执行</li>
<li>在该指令中一般写上方法的调用语法, 或直接进行数据赋值等操作.</li>
<li>而该指令中的名字( 标识符 )或方法调用, 其名字都是 背后对象的成员.</li>
</ul>
<p>配合 <code>ng-if</code> 可以控制点击行为, 来使得某些标签移除与添加. 例如:</p>
<pre><code class="lang-html">&lt;body ng-app&gt;
    &lt;a href=&quot;#&quot; ng-click=&quot;exit != exit&quot;&gt;点击测试&lt;/a&gt;
    &lt;ul ng-if=&quot;exit&quot;&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;数据数据&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;数据数据&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;数据数据&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
</code></pre>
<p>其运行效果为:</p>
<p><img src="./imgs/ng-click-ul-exit-and-remove.gif" alt=""></p>
<p>ng 中提供了很多类似的事件指令, 结合多个指令混合到一起使用会变得非常强大.</p>
<p>常见的事件指令有:</p>
<pre><code class="lang-javascript">    ngChange
    ngClick
    ngDblclick
    ngMousedown
    ngMouseup
    ngMouseover
    ngMouseenter
    ngMouseleave
    ngMousemove
    ngKeydown
    ngKeyup
    ngKeypress
    ngSubmit
    ngFocus
    ngBlur
    ngCopy
    ngCut
    ngPaste
</code></pre>
<p>其用法与 <code>ng-click</code> 一样, 意义如字面一样. </p>
<p>下面我们看一个案例, 效果如下: </p>
<p><img src="./imgs/table-mouseover-highlight.gif" alt=""></p>
<p>提供的数据如下:</p>
<pre><code class="lang-javascript">var data = [ {   
    name: &#39;纪明杰&#39;, 
    gender: &#39;m&#39;, 
    birthdate: &#39;1973-3-31&#39;, 
    join: &#39;2005-1-15&#39;, 
    address: &#39;四川省  阿坝藏族羌族自治州&#39;, 
    email: &#39;Corey19730331@yahoo.cn&#39;, 
    phone: &#39;13198561347&#39; 
}, { 
    name: &#39;邓健柏&#39;, 
    gender: &#39;m&#39;, 
    birthdate: &#39;1975-11-30&#39;,
    join: &#39;2008-1-15&#39;,
    address: &#39;广东省  潮州市&#39;, 
    email: &#39;Andrew19751130@yeah.net&#39;, 
    phone: &#39;13888543794&#39; 
}, { 
    name: &#39;濮阳语儿&#39;,
    gender: &#39;f&#39;,
    birthdate: &#39;1984-1-31&#39;,
    join: &#39;2012-5-15&#39;,
    address: &#39;安徽省  巢湖市&#39;, 
    email: &#39;Charlotte19840131@yahoo.cn&#39;, 
    phone: &#39;13918704172&#39; 
}, { 
    name: &#39;嵇志强&#39;, 
    gender: &#39;m&#39;, 
    birthdate: &#39;1979-7-31&#39;, 
    join: &#39;2007-12-15&#39;,
    address: &#39;河南省  漯河市&#39;, 
    email: &#39;Levi19790731@21cn.com&#39;,
    phone: &#39;15918104461&#39; },
{ 
    name: &#39;居博超&#39;, 
    gender: &#39;m&#39;, 
    birthdate: &#39;1986-12-31&#39;,
    join: &#39;2008-5-15&#39;,
    address: &#39;江苏省  南通市&#39;, 
    email: &#39;Enoch19861231@yahoo.com.cn&#39;, 
    phone: &#39;13825143219&#39; 
}, { 
    name: &#39;窦弘文&#39;, 
    gender: &#39;m&#39;, 
    birthdate: &#39;1974-2-28&#39;, 
    join: &#39;2007-5-15&#39;, 
    address: &#39;贵州省  安顺市&#39;, 
    email: &#39;Bartholomew19740228@yeah.net&#39;, 
    phone: &#39;15953281032&#39; 
}, { 
    name: &#39;邰浩然&#39;, 
    gender: &#39;m&#39;, 
    birthdate: &#39;1989-4-30&#39;, 
    join: &#39;2009-2-15&#39;, 
    address: &#39;广东省  茂名市&#39;, 
    email: &#39;King19890430@yahoo.com.cn&#39;, 
    phone: &#39;13824309057&#39; 
}, { 
    name: &#39;弓天磊&#39;, 
    gender: &#39;m&#39;, 
    birthdate: &#39;1986-12-31&#39;,
    join: &#39;2005-11-15&#39;, 
    address: &#39;安徽省  黄山市&#39;, 
    email: &#39;Bowen19861231@yahoo.cn&#39;, 
    phone: &#39;15844437988&#39; 
} ];
</code></pre>
<p>简要分析实现过程:</p>
<ul>
<li>首先根据数据可以看到是一个数组, 因此可以构造表格结构.</li>
</ul>
<pre><code class="lang-html">&lt;table border=&quot;1&quot; width=&quot;1200&quot;&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;编号&lt;/th&gt;
            &lt;th&gt;姓名&lt;/th&gt;
            &lt;th&gt;性别&lt;/th&gt;
            &lt;th&gt;出生年月&lt;/th&gt;
            &lt;th&gt;入职时间&lt;/th&gt;
            &lt;th&gt;家庭住址&lt;/th&gt;
            &lt;th&gt;邮箱&lt;/th&gt;
            &lt;th&gt;电话&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr ng-repeat=&quot;item in list&quot;&gt;...&lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<ul>
<li>考虑到 data 数组中的项是一个对象, 因此利用 <code>item</code> 引用该项这一特点, 可以开始写 <code>&lt;tr&gt;</code> 中数据的模板. 利用内置变量 <code>$index</code> 来输出序号.</li>
</ul>
<pre><code class="lang-html">&lt;tr ng-repeat=&quot;item in list&quot;&gt;
    &lt;td&gt;{{ $index }}&lt;/td&gt;
    &lt;td&gt;{{ item.name }}&lt;/td&gt;
    &lt;td&gt;{{ item.gender }}&lt;/td&gt;
    &lt;td&gt;{{ item.birthdate }}&lt;/td&gt;
    &lt;td&gt;{{ item.join }}&lt;/td&gt;
    &lt;td&gt;{{ item.address }}&lt;/td&gt;
    &lt;td&gt;{{ item.email }}&lt;/td&gt;
    &lt;td&gt;{{ item.phone }}&lt;/td&gt;
&lt;/tr&gt;
</code></pre>
<ul>
<li>需要让鼠标悬浮的时候高量, 可以提供一个类样式</li>
</ul>
<pre><code class="lang-css">.light {
    background-color: yellow;
}
</code></pre>
<ul>
<li>需要显示高亮, 只需要提供 <code>class=&quot;light&quot;</code> 的类样式即可.</li>
<li>但是需要鼠标悬浮才有该样式, 鼠标移开移除该类样式, 所以可以用背后的对象维护一个变量 <code>over</code>, 表示是否鼠标悬浮.</li>
<li>在 <code>&lt;tr&gt;</code> 上使用 <code>ng-mouseover</code> 与 <code>ng-mouseleave</code> 指令, 来给 <code>over</code> 提供数据</li>
</ul>
<pre><code class="lang-html">&lt;tr ng-repeat=&quot;item in list&quot; 
    ng-mouseover=&quot;over = 1&quot; 
    ng-mouseleave=&quot;over = 0&quot; 
    class=&quot;{{ over ? &#39;light&#39; : &#39;&#39; }}&quot;&gt;
</code></pre>
<ul>
<li>然后在代码中创建模块, 给 <code>$rootScope</code> 提供 <code>list</code> 成员</li>
</ul>
<pre><code class="lang-javascript">angular.module( &#39;app&#39;, [] )
    .run( function ( $rootScope ) {
        $rootScope.list = data;
    });
</code></pre>
<ul>
<li>最后运行即可. </li>
</ul>
<p>ng 的所有事件指令的使用, 实际上与一般 dom 提供的事件使用方法是一样的.</p>
<h1 id="-">常用内置指令( 续 )</h1>
<p>接下来继续讨论内置指令: </p>
<!-- ## 属性与样式指令

所谓的属性指令, 是说原本标签就有的属性, 但是在 ng 环境中原有属性的使用会出现问题, 所以 ng 对部分属性进行了封装,
得到了一些属性指令. 它们包括: `ng-href`, `ng-src`. 
事实上, 样式也是属性中的一种, 只是使用的过于频繁, 所以我们将其单独分类, 它包括: `ngClass`, `ngCloak`, `ngShow`, `ngHide`, 和 `ngStyle`. -->
<h2 id="-ng-href-ng-src-"><code>ng-href</code> 与 <code>ng-src</code> 指令</h2>
<p>这些指令的只用与标签属性的使用一样, 但是功能会更加 &quot;智能&quot; 点. 
例如在 ng 中如果需要设置一张图片的地址, 可以将代码写成: </p>
<pre><code class="lang-html">&lt;img src=&quot;{{ imgUrl }}&quot; alt=&quot;图片&quot;&gt;
</code></pre>
<p>但是 ng 的执行是需要时间的, 浏览器先要下载 html, css, js 等文件, 然后下载这些文件后, 需要解析 html, 
渲染 css, 同时要执行 js 代码. ng 的代码如果需要从网络中下载执行就会需要花费一些时间( 因为 ng 的库相对较大, 
而且需要配合网速, 网速一般是不确定的 ). 所以如果在 ng 执行结束之前, 在页面中图片就不会显示出来, 甚至显示一个错误的图片效果. 例如:</p>
<p><img src="./imgs/2018-02-02_174139.png" alt=""></p>
<p>所以为了提高用户的体验, 应该更换成 <code>ng-src</code> 指令, 写成: </p>
<pre><code class="lang-html">&lt;img ng-src=&quot;{{ imgUrl }}&quot; alt=&quot;图片&quot;&gt;
</code></pre>
<p>那么在 ng 程序执行结束之前, <code>img</code> 标签是没有 <code>src</code> 属性的, 也就不会发送图片请求. 在 ng 程序运行结束后,
背后的对象就会含有 <code>imgUrl</code> 属性, 同时含有数据. 同时 ng 就会将 <code>img</code> 标签的 <code>ng-src</code> 属性替换成 <code>src</code>
属性, 浏览器再发送图片请求, 从而显示图片.</p>
<p><code>ng-href</code> 指令的用法与 <code>ng-src</code> 指令的用法是一样的.</p>
<h2 id="-">样式相关指令</h2>
<p>实际上设置标签的样式可以直接使用:</p>
<pre><code class="lang-html">&lt;tag class=&quot;{{ className }}&quot;&gt;...&lt;/tag&gt;
&lt;tag style=&quot;{{ styleValue }}&quot;&gt;...&lt;/tag&gt;
</code></pre>
<p>不过 ng 提供了更加好用的对应指令. 它们分别是: <code>ngClass</code>, <code>ngStyle</code>, <code>ngCloak</code>, <code>ngShow</code>, <code>ngHide</code>.</p>
<h3 id="-ng-class-"><code>ng-class</code> 指令</h3>
<p>该指令的语法为:</p>
<pre><code class="lang-html">&lt;tag ng-class=&quot;表达式&quot;&gt;...&lt;/tag&gt;
</code></pre>
<p>说明:</p>
<ul>
<li><code>ng-class</code> 指令有三种用法: 字符串, 对象, 或数组.</li>
<li>如果表达式的结果是一个字符串, 那么字符串可以使用一个用空格分隔开的各个类样式的名字.</li>
<li>如果表达式的结果是一个对象, 那么该对象的每一个键值对用于表示该标签可以使用的类样式. 键值为 <code>true</code> 的键名会作为类样式的名字用于该标签.</li>
<li>如果表达式的结果是一个数组, 那么数组的元素必然是第一种或第二种情况.</li>
</ul>
<p>使用案例: (略)</p>
<h3 id="-ng-style-"><code>ng-Style</code> 指令</h3>
<p>该指令的语法为:</p>
<pre><code class="lang-html">&lt;tag ng-style=&quot;表达式&quot;&gt;...&lt;/tag&gt;
</code></pre>
<p>说明:</p>
<ul>
<li>表达式的结果应该是一个对象, 对象的键值对构成 css 的样式属性与对应的值</li>
</ul>
<p>使用案例: (略)</p>
<!-- ## 表单指令 -->
<!-- ## 其他指令 -->
<h1 id="-controller-scope-">控制器( controller )与作用域( scope )</h1>
<p>我们首先来看一个案例:</p>
<p><img src="./imgs/constroller-demo.gif" alt=""></p>
<p>在该案例中有两组输入框, 每一组输入框由两个文本框组成. 每一组都有一个功能, 就是输入其中一个文本框,
另一个文本框会同步数据; 若对另一个文本框做同样的事情, 对应的文本框也会提供数据的同步. 
思考一下这个怎么实现呢?</p>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>